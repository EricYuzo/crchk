#! /usr/bin/env bash

error() {
    echo "$PROGRAM: $@" 1>&2
    usage
    exit 1
}

check_dependencies() {
    command -v crc32 > /dev/null
    if [ $? -ne 0 ] ; then
        error "program crc32 missing."
    fi
}

usage() {
    echo "Usage: $PROGRAM [OPTION]... FILE..."
    echo "Try '$PROGRAM --help' for more information."
}

showhelp() {
    echo "Usage: $PROGRAM [OPTION]... FILE..."
    echo
    echo "Check FILE integrity based on CRC-32."
    echo "Directories are skipped, by default. You can use -r option to handle directories recursively."
    echo
    echo "Available options:"
    echo "  -a, --append-crc       append calculated CRC to file name"
    echo "  -b, --brackets=TYPE    TYPE of brackets used to enclose CRC appended to file name;"
    echo "                         TYPE is 'square', 'round', or 'curly'"
    echo "  -f, --file=FILE        verify FILE"
    echo "  -g, --generate-sfv     generate SFV file"
    echo "  -h, --help             display this help and exit"
    echo "  -i, --ignore-sfv       ignore SFV files"
    echo "  -r, --recursive        recursively look for files inside directories"
    echo "  -s, --sep=TEXT         TEXT added between file name and appended CRC"
    echo "      --separator=TEXT"
    echo "  -u, --uppercase        display uppercase CRC code;"
    echo "                         if -a is specified, append uppercase CRC to file name"
    echo "  -v, --version          display version information and exit"
}

showversion() {
    echo "$PROGRAM version $VERSION"
}

extract_crc() {
    regex='^.*[[({]\([0-9A-Fa-f]\{8\}\)[])}].*$'
    echo "$1" | grep -q "$regex"
    if [ $? -eq 0 ] ; then
        echo "$1" | tr "$tr_set1" "$tr_set2" | sed "s/${regex}/\1/"
    else
        echo "$not_found"
    fi
}

compare() {
    detected_crc=$1
    calculated_crc=$2
    if [ "$detected_crc" = "$calculated_crc" ] ; then
        echo "ok"
    elif [ "$detected_crc" = "$not_found" ] ; then
        echo "$not_found"
    else
        echo "corrupted"
    fi
}

verify() {
    file_name="$@"
    crc_source='filename'
    detected_crc=$(extract_crc "$file_name")
    calculated_crc=$(crc32 "$file_name" | tr "$tr_set1" "$tr_set2")
    status=$(compare $detected_crc $calculated_crc)
    echo "$file_name    $crc_source    $detected_crc    $calculated_crc    $status"
    if [ "$generatesfv" = "yes" ] ; then
        sfvdir=$(dirname "$file_name")
        sfvname=$(basename "$sfvdir").sfv
        if [ ! -f  "$sfvdir/$sfvname" ] || [ $(date +%s -r "$sfvdir/$sfvname") -ge $exectime  ] ; then
            fname=$(basename "$file_name")
            echo "$fname $calculated_crc" >> "$sfvdir/$sfvname"
        fi
    elif [ "$appendcrc" = "yes" ] && [ "$detected_crc" = "$not_found" ] ; then
        fname="${file_name%.*}"
        fext="${file_name##*.}"
        mv "$file_name" "$(echo ${append_pattern} | sed "s/\([^%]\)\?%NAME/\1${fname}/" | sed "s/\([^%]\)\?%CRC/\1${calculated_crc}/" | sed "s/\([^%]\)\?%EXT/\1${fext}/" )"
    fi
}

verify_sfv() {
    re='^\(.\+\) \([0-9A-Fa-f]\{8\}\)\s*$'
    echo "$@" | grep -q "$re"
    if [ $? -eq 0 ] ; then # ignore invalid SFV lines
        file_name=$(echo "$@" | sed "s/${re}/\1/")
        crc_source='sfv'
        detected_crc=$(echo "$@" | sed "s/${re}/\2/" | tr "$tr_set1" "$tr_set2")
        calculated_crc=$(crc32 "$file_name" | tr "$tr_set1" "$tr_set2")
        status=$(compare $detected_crc $calculated_crc)
        echo "$file_name    $crc_source    $detected_crc    $calculated_crc    $status"
    fi
}

process() {
    for f in "$@"
    do
        if [ -d "$f" ] && [ "$recursive" = "yes" ] ; then
            if [[ "$f" == */ ]] ; then
                f=${f%/*}
            fi
            if [ "$ignoresfv" = "no" ] && [ -f "$f"/*.sfv ] ; then
                process "$f"/*.sfv "$f"/*/
            else
                process "$f"/*
            fi
        elif [ -f "$f" ] ; then
            if [[ "$f" == *.sfv ]] ; then
                if [ "$ignoresfv" = "no" ] ; then
                    read_sfv "$f"
                fi
            else
                verify $f
            fi
        fi
    done
}

read_sfv() {
    OLDIFS=$IFS
    IFS='
'
    base=$(dirname "$1")
    for l in $(cat "$1" | grep -v '^\s*;')
    do
        verify_sfv "$base/$l"
    done
    IFS=$OLDIFS
}

main() {
    check_dependencies

    # parse options {
    positional=()
    while [ $# -gt 0 ]
    do
        case $1 in
            -b )
                case $2 in
                    square )
                        delim1='['
                        delim2=']'
                        ;;
                    round | parentheses )
                        delim1='('
                        delim2=')'
                        ;;
                    curly | braces )
                        delim1='{'
                        delim2='}'
                        ;;
                    * )
                        error "Invalid enclosing brackets: $2"
                        ;;
                esac
                shift
                ;;
            --brackets=* )
                case ${1#*=} in
                    square )
                        delim1='['
                        delim2=']'
                        ;;
                    round | parentheses )
                        delim1='('
                        delim2=')'
                        ;;
                    curly | braces )
                        delim1='{'
                        delim2='}'
                        ;;
                    * )
                        error "Invalid enclosing brackets: ${1#*=}"
                        ;;
                esac
                ;;
            -f )
                positional+=("$2")
                shift
                ;;
            --file=* )
                positional+=("${1#*=}")
                ;;
            -h | --help | '-?' | '--?' )
                showhelp
                exit 0
                ;;
            -s )
                sep=$2
                shift
                ;;
            --sep=* | --separator=* )
                sep="${1#*=}"
                ;;
            -v | --ver | --version )
                showversion
                exit 0
                ;;
            -* )
                optfound="no"
                if [[ $1 =~ ^(-[giru]*a[giru]*|--append-crc)$ ]] ; then
                    appendcrc="yes"
                    optfound="yes"
                fi
                if [[ $1 =~ ^(-[airu]*g[airu]*|--generate-sfv)$ ]] ; then
                    generatesfv="yes"
                    optfound="yes"
                fi
                if [[ $1 =~ ^(-[agru]*i[agru]*|--ignore-sfv)$ ]] ; then
                    ignoresfv="yes"
                    optfound="yes"
                fi
                if [[ $1 =~ ^(-[agiu]*r[agiu]*|--recursive)$ ]] ; then
                    recursive="yes"
                    optfound="yes"
                fi
                if [[ $1 =~ ^(-[agir]*u[agir]*|--uppercase)$ ]] ; then
                    tr_set1='[a-f]'
                    tr_set2='[A-F]'
                    optfound="yes"
                fi
                if [ "$optfound" = "no" ] ; then
                    error "Unrecognized option: $1"
                fi
                ;;
            * )
                positional+=("$1")
                ;;
        esac
        shift
    done
    set -- "${positional[@]}"
    # }

    process "$@"
}


exectime=$(date +%s)

appendcrc="no"
generatesfv="no"
ignoresfv="no"
recursive="no"

append_pattern='%NAME_[%CRC].%EXT'
delim1='['
delim2=']'
not_found='NA'
sep='_'
tr_set1='[A-F]'
tr_set2='[a-f]'

PROGRAM=$(basename $0)
VERSION="0.1.0"

main "$@"
